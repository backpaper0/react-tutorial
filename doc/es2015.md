# JavaScript(ES2015)

まずはJavaScriptの文法や演算子、ビルトインオブジェクト（最初から用意されているオブジェクトのこと）を学ぼう。

## 事前準備

Node.jsのファイルAPIを使用して

元となる疑似個人情報は次のサービスで作成する。

* https://hogehoge.tk/personal/generator/

「年齢」と「血液型」
血液型

生成する件数を1000件ぐらいにして「生成開始」をクリックしよう。
疑似個人情報が生成されるので、画面の一番したまでスクロールしてCSV(文字コード:UTF-8)でダウンロードしよう。
`personal_infomation.csv`というファイル名でダウンロードされるはず。

コマンドプロンプトを開いて`personal_infomation.csv`が置いてあるディレクトリに移動しよう。
次のコマンドを実行するとNode.jsのREPLが起動する。
（JavaScriptに限らず対話型の実行環境のことをREPLと呼ぶ。JavaにもJShellというREPLがある）

```console
node
```

これで準備はOK。

## ファイルを読み込んで変数に代入する

まずは事前準備した疑似個人情報が書かれたファイルを読み込んでみよう。

Node.jsからファイル操作を行うAPIが提供されているのでそれを使う。
起動しているREPLに次のコードを打ち込んで`Enter`を押してみよう。

```js
fs.readFileSync('personal_infomation.csv', 'UTF-8');
```

コンソールにファイルの内容が表示されるはず。

REPLは実行した結果（戻り値）をコンソールに表示する。
この場合、`fs.readFileSync`メソッドが読み込んだファイルの内容を戻り値として返している。

この先何度もファイルの内容を扱うので変数に代入しておこう。
REPLに次のコードを打ち込んで`Enter`を押してみよう。

```js
const data = fs.readFileSync('personal_infomation.csv', 'UTF-8');
```

実はJavaScriptには変数の種類がいくつかある。
`const`、`let`、`var`だ。

`const`は再代入不可、`let`は再代入可能となっている。
私の経験的に1つの変数を使いまわすとバグを生みやすい。
それを防ぐためになるべく`const`を使うようにしよう。

もちろん、どうしても再代入をする必要がある場合は`let`を使ってよい。
しかし`let`を使う前に必ず`const`を使えないか考えてほしい。

最後に`var`についてだけど、これは特に使う場面は無い。
昔のJavaScriptは変数宣言をする手段は`var`しかなかったけど、今は`const`と`let`がある。
なので、昔のシステムの保守や改修をするときに目にすることはあるかもしれないけれど、このチュートリアルでは使わない。

|種類|モダン|再代入|スコープ|使用|
|---|---|---|---|---|
|`const`|モダン|再代入不可|ブロック|推奨|
|`let`|モダン|再代入可能|ブロック|使ってもよい|
|`var`|レガシー|再代入可能|関数|使わない|

さて、さきほどファイルの内容を変数に代入したけれど、1つの文字列になっている。
これだと少し扱いにくいので、行ごとに分けて配列形式で持つようにしよう。
文字列を分割するには`split`メソッドが使える。

```js
const lines = data.split('\r\n');
```

変数の中身を単に見たい場合はREPLに変数を打ち込んで`Enter`を押せばよい。
試しに`lines`の中身を見てみよう。

## 名前に「上」を含む人物を絞り込む

ファイルの内容を行ごとに分割して`lines`に代入した。
今度は`lines`を1行ずつ見て名前に「上」を含むものだけに絞り込もう。

文字列が特定の文字列を含むかどうかは`indexOf`を使って判定できる。

```js
//対象文字列が見つかったら頭のインデックスを返す
'ABCDEFG'.indexOf('DEF') //3
//見つからなければ-1を返す
'ABCDEFG'.indexOf('XYZ') //-1
```

それでは配列である`lines`の要素1つずつに`indexOf`を実行して絞り込むにはどうすればよいか？

配列には要素を絞り込むための`filter`というメソッドが用意されている。
次のコードで名前に「上」を含む人物に絞り込める。

```js
lines.filter(x => x.indexOf('上') !== -1);
```

`filter`は関数を受け取り、絞り込んだ結果を新しい配列として返すが、この例で`filter`が受け取っている関数だけ抜き出したコードはこれ。

```js
x => x.indexOf('上') !== -1
```

この文法はアロー関数という。
`=>`の左辺で引数を宣言して右辺が関数の本体になっている(ちなみに`=>`が矢（arrow）のように見えるからアロー関数という）。

この例では本体が1行しかないのでいくつか省略しているものがある。

まずはブロックの括弧だ。
関数本体が複数行になる場合は本体を`{`と`}`で囲む必要がある（もちろん1行しかなくてもブロックにしてもよい）。
それから`return`も省略されている。
関数本体が1行しかないときは最後に評価された式の結果が戻り値となる。

この1行で書かれたアロー関数の例にあえてブロックと`return`を書くとこうなる。

```js
x => {
    return x.indexOf('上') !== -1;
}
```

つまり、このアロー関数は「1つの引数を取って、その引数に『上』が含まれていれば`true`を、含まれていなければ`fales`を返す関数」というわけ。

ちなみに関数を作る方法には`function`式というものもある。
これは`var`と同じく古いJavaScriptの名残だと思ってよいだろう。
私の感覚では`function`式がなくてもコードは書けるし、アロー関数の方がシンプルで好きだ。
一応、`function`式で例を書き換えたコードも示しておく。

```js
//function式はブロックの括弧もreturnも省略できない
function (x) {
    return x.indexOf('上') !== -1;
}
```

さて、話を`filter`に戻そう。
`filter`は配列の要素1つずつに対して、引数で渡された関数を適用して、戻り値が`true`のものだけに絞り込んだ新しい配列を返す。

`filter`の概念を図で表すと次のような感じ。

TODO 絵

エアコンにはフィルターが取り付けられていてゴミを取り除く役割がある。
`filter`もそれと似た機能で、（ゴミと呼ぶのは気が引けるけど）不要な要素を取り除く。

いくつか`filter`のサンプルを示そう。

```js
[1, 2, 3, 4].filter(x => x % 2 == 0) //[2, 4]
[true, false].filter(x => x) //[true]
['foo', 'bar', 'baz'].filter(x => x[0] === 'b') //['bar', 'baz']
```

次に行く前に絞り込んだ結果を新たな変数に代入しておこう。

```js
const filtered = lines.filter(x => x.indexOf('上') !== -1);
```

## 性別を抜き出す

今は1行のデータに名前や性別、生年月日が含まれている。
この中から性別だけを抜き出して新しい配列を作ろう。

データはCSV形式なので性別を抜き出すには`,`で分割して4番目の項目を取ってくればよい。
分割と抜き出しを配列が持つすべての要素に適用するには`map`メソッドを使う。

```js
filtered.map(x => x.split(',')[3]);
```

今回もアロー関数だけを抜き出してみよう。

```js
x => x.split(',')[3]
```

このアロー関数は「1つの引数を取って、その引数を`,`で分割して4番目の項目（配列は`0`オリジンなのでインデックスは`3`を指定）を返す関数」だ。

これを`map`メソッドに渡して`filtered`配列のすべての要素に適用して、戻り値からなる新しい配列を返している。

`map`の概念を図で表すと次のような感じ。

TODO 絵

データベース上のカラムとJavaのエンティティクラスのプロパティを対応付けるようなことをマッピングと呼ぶ場合がある。
`map`は元の配列と、戻り値として返される新しい配列の要素を関数によってマッピングする。

いくつか`map`のサンプルを示そう。

```js
[1, 2, 3, 4].map(x => x * 2) //[2, 4, 6, 8]
[true, false].map(x => x === false) //[false, true]
['foo', 'bar', 'baz'].map(x => x.toUpperCase()) //['FOO', 'BAR', 'BAZ']
```

次に行く前に絞り込んだ結果を新たな変数に代入しておこう。

```js
const mapped = filtered.map(x => x.split(',')[3]);
```

## 集計用のクラスを作る

性別の配列から男性・女性それぞれ何人なのか集計したい。
集計には`reduce`が使えるが、コードが煩雑になってしまうのを防ぐために先回りして集計用のクラスを作っておこう。

男性（male）の人数を保持するフィールドと女性（female）の人数を保持するフィールドを持たせる。
それから`'男'`または`'女'`という文字列を受け取って人数をカウントアップするメソッドを持たせる。
このメソッドは新たな`Counter`インスタンスを返すイミュータブルな設計にしてある。

次のコードをREPLに打ち込んで`Enter`を押そう。
コード量もちょっと多いしコピペしてもよい。

```js
class Counter {

  constructor(m, f) {
    this.m = m;
    this.f = f;
  }

  add(x) {
    if(x === '男'){
      return new Counter(this.m + 1, this.f);
    }
    return new Counter(this.m, this.f + 1);
  }

  static empty() {
      return new Counter(0, 0);
  }
}
```

クラスの宣言は`class`キーワードにクラス名を続けて行う。
この例だとクラス名は`Counter`だ。

コンストラクタは`constructor`キーワードで定義する。
例からコンストラクタを抜粋したものがこれ。

```js
constructor(m, f) {
  this.m = m;
  this.f = f;
}
```

このコンストラクタでは2つの引数`m`と`f`を受け取って、それぞれフィールド`m`と`f`に代入している。

次にメソッドだけど、この例では`add`というメソッドを定義している。

```js
add(x) {
  if(x === '男'){
    return new Counter(this.m + 1, this.f);
  }
  return new Counter(this.m, this.f + 1);
}
```

`add`メソッドは1つの引数`x`を受け取っている。
`x`が`'男'`ならフィールド`m`に`+1`した値とフィールド`f`を渡して新しい`Counter`インスタンスを作って返している。
`x`が`'男'`でなければ（今回は`x`は必ず`'男'`か`'女'`のどちらかだという前提）フィールド`m`とフィールド`f`に`+1`した値を渡して新しい`Counter`インスタンスを作って返している。

最後に`static`メソッドを定義している。

```js
static empty() {
  return new Counter(0, 0);
}
```

メソッド定義をするときメソッド名の前に`static`キーワードを付けると`static`メソッドとなる。
このメソッドはクラスをレシーバとして呼び出す。

```js
//staticメソッドを呼び出す例
Counter.empty();
```

## 男女別に人数を集計する

さて、集計用のクラスも作ったし、今後こそ集計しよう。
集計も`filter`や`map`と同じように配列が持つメソッドを使う。
使うメソッドは`reduce`だ。

次のコードで男女別に人数を集計できる。

```js
mapped.reduce((counter, x) => counter.add(x), Counter.empty())
```

ちょっとこのメソッドは`filter`や`map`よりは分かりにくいかもしれないけれど、少しずつ理解しよう。

`reduce`は2つの引数を取っている。
1つめは関数、2つめは初期値だ。

```js
//関数
(counter, x) => counter.add(x)

//初期値
Counter.empty()
```

初期値は男女共に`0`のカウンターだということは分かると思う（分からなければ`empty`メソッドの定義をもう一度見てみよう）。

関数は2つの引数、`counter`と`x`を取って`counter`に`x`を`add`して取得した戻り値を、返している。
この関数は`mapped`配列のすべての要素に対して呼び出され、引数`x`には配列の要素が渡されるが、これは`filter`や`map`と同じ動作だ。

特徴的なのは引数`counter`だ。
`reduce`が配列の先頭の要素を処理するとき、引数`counter`には「`reduce`の第2引数で渡されたカウンター」が渡される。
`reduce`が2番目の要素（インデックスは`1`）を処理するとき、引数`counter`には「先頭の要素を処理した結果（つまり先頭の要素で`counter.add(x)`した戻り値）」が渡される。
`reduce`が3番目の要素（インデックスは`2`）を処理するとき、引数`counter`には「2番目の要素（インデックスは`1`）を処理した結果」が渡される。

このように、`reduce`は初期値またはその時点での計算結果と配列の要素を受け取って、新たな計算結果を返すことを配列の要素ぶん繰り返す処理と言える。

`reduce`の概念を図で表すと次のような感じ。

TODO 絵

`reduce`の初期値・途中の計算結果（この例だと`counter`）のことを一般的には「アキュムレータ」と呼ぶ。
`reduce`の動作は「畳み込み」と呼ばれることもある。
配列が持つ複数の要素を1つのアキュムレータに畳み込む、というと納得してもらえるかな？
まあ納得できなくても、`reduce`を調べると「アキュムレータ」や「畳み込み」という言葉が出てくることもある、と思っておいて。

いくつか`reduce`のサンプルを示そう。

```js
[1, 2, 3, 4].reduce((acc, x) => acc + x, 0) //10
[true, false].reduce((acc, x) => acc && x, true) //false
['foo', 'bar', 'baz'].reduce((acc, x) => `${acc}${x}`, '') //'foobarbaz'
```

## おまけ

ここまで終えると1000件以上の疑似個人情報から「名前に『上』を含む人物の性別ごとの人数」を得られた。

せっかくなので集計結果をファイルに書き出そう。
更に、ここまでのコードを1つのjsファイルに書いてREPLではなくてスクリプトとして実行してみよう。

次のコードを`count.js`という名前のファイルに保存しよう。
保存する場所はREPLを開いている場所、つまり疑似個人情報のCSVファイルが置かれているディレクトリだ。

```js
const fs = require('fs');

const data = fs.readFileSync('personal_infomation.csv', 'UTF-8');
const lines = data.split('\r\n');
const filtered = lines.filter(x => x.indexOf('上') !== -1);
const mapped = filtered.map(x => x.split(',')[3]);

class Counter {

  constructor(m, f) {
    this.m = m;
    this.f = f;
  }

  add(x) {
    if(x === '男'){
      return new Counter(this.m + 1, this.f);
    }
    return new Counter(this.m, this.f + 1);
  }

  static empty() {
      return new Counter(0, 0);
  }
}

const reduced = mapped.reduce((counter, x) => counter.add(x), Counter.empty());
fs.writeFileSync('count.txt', `男性：${reduced.m}人、女性：${reduced.f}人`, 'UTF-8');
```

1行目と最終行が新しく追加されたコードになる。

```js
//1行目のコード
const fs = require('fs');

//最終行のコード
fs.writeFileSync('count.txt', `男性：${reduced.m}人、女性：${reduced.f}人`, 'UTF-8');
```

1行目のコードは`fs`モジュールを使えるようにするための宣言だ。
REPLではデフォルトで使えるようになっていたのでこのコードが不要だった。
スクリプト実行するときは必要になる。

それから最終行はファイルを書き出しているコードだ。

さあ、次のコマンドでこのスクリプトを実行しよう。
集計結果が`count.txt`に書き出される。

```console
node count.js
```

日常でもちょっとファイルを編集したり集計したいときがあると思うけれど、そういったときに使えるツールの1つにJavaScriptが加わったんじゃないだろうか？

今回作った集計コードにはいくつか注意点がある。

* 疑似個人情報ファイルの内容をすべて読み込んで処理をしているのでメモリに優しくはない
* 読み書きするファイル名がスクリプトにハードコーディングされているのでポータビリティは低い

次のステップとして、これらの注意点を解消するような改善をしてみるのも面白いかもしれない。
